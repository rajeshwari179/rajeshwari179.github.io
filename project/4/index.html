<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/rajeshwari179.github.io/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/rajeshwari179.github.io/_next/static/css/e0b7e5d5ffdc86c6.css" data-precedence="next"/><link rel="stylesheet" href="/rajeshwari179.github.io/_next/static/css/3cc226f0877344cc.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/rajeshwari179.github.io/_next/static/chunks/webpack-6238dfa248d38f1e.js"/><script src="/rajeshwari179.github.io/_next/static/chunks/fd9d1056-cb422f7581ecfa2f.js" async=""></script><script src="/rajeshwari179.github.io/_next/static/chunks/23-75e956f4d16d7bd4.js" async=""></script><script src="/rajeshwari179.github.io/_next/static/chunks/main-app-eb2e0dafa72a0a0f.js" async=""></script><script src="/rajeshwari179.github.io/_next/static/chunks/173-45ae19e0432c0727.js" async=""></script><script src="/rajeshwari179.github.io/_next/static/chunks/app/project/4/page-51c71a4d71300c50.js" async=""></script><script src="/rajeshwari179.github.io/_next/static/chunks/231-af777def82264613.js" async=""></script><script src="/rajeshwari179.github.io/_next/static/chunks/app/layout-7513d9a03965dc6e.js" async=""></script><title>Create Next App</title><meta name="description" content="Generated by create next app"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><script src="/rajeshwari179.github.io/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_ae7d09"><div id="title" class="title"></div><div id="navbar" class="Navbar_navbar__fk_p7"><p class="Navbar_inactive__I_vRp"><a href="/">Home</a></p><p class="Navbar_inactive__I_vRp"><a href="/about/">Experience</a></p><p class="Navbar_inactive__I_vRp"><a href="/project/">Projects</a></p><p class="Navbar_inactive__I_vRp"><a href="/designs/">Designs</a></p></div><div style="border:2px solid #000;padding:20px;border-radius:10px"><h1>Toy Particle Simulation through Shared Memory Programming</h1><div class="ProjectTemplate_box__pk1Aa"><div style="flex:1"><div class="ProjectTemplate_descriptionContainer__g40_B"><h2>Introduction</h2><p class="ProjectTemplate_projectDescription__RSofK">This project focuses on parallelizing a toy particle simulation, a simplified model commonly used in mechanics, biology, and astronomy. In this simulation, particles interact by repelling each other when they come within a specified cutoff distance. This model helps in understanding the dynamics of particle systems and their interactions over time.<ul><li>To enhance the performance of the particle simulation, parallel computing techniques using OpenMP and CUDA are employed.</li><li> OpenMP allows for efficient distribution of the workload across multiple CPU threads, while CUDA enables offloading computations to the GPU, leveraging its massively parallel architecture. These technologies significantly speed up the simulation, enabling the handling of larger particle systems with greater detail</li></ul></p></div></div><div class="ProjectTemplate_imageSection__fIgKC"><div class="ProjectTemplate_imageContainer__Xmpvw"><div class="ProjectTemplate_customImage__wSvfz"><img alt="Project Introduction" loading="lazy" decoding="async" data-nimg="fill" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" sizes="100vw" srcSet="/_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc4.934b01cd.png&amp;w=640&amp;q=75 640w, /_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc4.934b01cd.png&amp;w=750&amp;q=75 750w, /_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc4.934b01cd.png&amp;w=828&amp;q=75 828w, /_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc4.934b01cd.png&amp;w=1080&amp;q=75 1080w, /_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc4.934b01cd.png&amp;w=1200&amp;q=75 1200w, /_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc4.934b01cd.png&amp;w=1920&amp;q=75 1920w, /_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc4.934b01cd.png&amp;w=2048&amp;q=75 2048w, /_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc4.934b01cd.png&amp;w=3840&amp;q=75 3840w" src="/_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc4.934b01cd.png&amp;w=3840&amp;q=75"/></div></div><p class="ProjectTemplate_imageDescription__B6C1V">Grid based Interaction</p></div></div><div class="ProjectTemplate_box__pk1Aa"><div style="flex:1"><div class="ProjectTemplate_descriptionContainer__g40_B"><h2>Grid-Based Method for Optimization</h2><p class="ProjectTemplate_projectDescription__RSofK">Optimization of force calculations between particles is achieved through a grid-based method. In this approach, the 2D simulation space is divided into grid cells, with each cell&#x27;s dimensions equal to the cutoff radius of the particles. This spatial partitioning confines the interaction calculations to particles within the same cell or adjacent cells, thus reducing the number of necessary calculations.<ul><li>Efficient Force Calculation: The grid-based method reduces computational complexity by focusing only on interactions between nearby particles.</li><li>Partitioning the Space: The 2D space is divided into grid cells, each matching the particle interaction cutoff distance</li><li>Managing Particles with Sets: Particle indices within each grid cell are managed using sets, ensuring uniqueness within each cell</li><li>Localized Force Computation: Forces are calculated only between particles in the same cell or neighboring cells, minimizing the number of interactions considered.</li></ul>Combining the grid-based method with parallel computing techniques results in a highly efficient simulation, capable of handling large-scale particle systems with improved performance. This project demonstrates the effective use of spatial partitioning and parallelization to optimize computationally intensive simulations.</p></div></div><div class="ProjectTemplate_imageSection__fIgKC"><div class="ProjectTemplate_imageContainer__Xmpvw"><div class="ProjectTemplate_customImage__wSvfz"><img alt="Project Grid-Based Method for Optimization" loading="lazy" decoding="async" data-nimg="fill" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" sizes="100vw" srcSet="/_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc1.84710b57.png&amp;w=640&amp;q=75 640w, /_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc1.84710b57.png&amp;w=750&amp;q=75 750w, /_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc1.84710b57.png&amp;w=828&amp;q=75 828w, /_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc1.84710b57.png&amp;w=1080&amp;q=75 1080w, /_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc1.84710b57.png&amp;w=1200&amp;q=75 1200w, /_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc1.84710b57.png&amp;w=1920&amp;q=75 1920w, /_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc1.84710b57.png&amp;w=2048&amp;q=75 2048w, /_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc1.84710b57.png&amp;w=3840&amp;q=75 3840w" src="/_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc1.84710b57.png&amp;w=3840&amp;q=75"/></div></div><p class="ProjectTemplate_imageDescription__B6C1V"> Strong scalling for 50000 paricles  </p></div></div><div class="ProjectTemplate_box__pk1Aa"><div style="flex:1"><div class="ProjectTemplate_descriptionContainer__g40_B"><h2>Methodologies used in the code</h2><p class="ProjectTemplate_projectDescription__RSofK"><ul><li>Counting Particles per Bin (fill count kernel): Iterates over all particles to determine the number of particles in each bin. Uses atomic operations to increment bin counts to avoid race conditions.</li><li>Calculating Cumulative Offset (calc cumulative offset step function): Performs an inclusive scan operation on the bin count array to compute cumulative sums, generating offsets that indicate particle positions in the particles array.</li><li>Binning Particles (binning kernel): Assigns each particle to its appropriate bin based on computed offsets. Uses atomic operations to ensure correct placement within the particles array.</li><li>Efficient Binning with Offset Array: Utilizes an offset array to store cumulative offsets, optimizing particle assignment to bins without the need for sorting. This approach reduces memory overhead and maximizes GPU parallelism for efficient particle simulation.</li></ul></p></div></div><div class="ProjectTemplate_imageSection__fIgKC"><div class="ProjectTemplate_imageContainer__Xmpvw"><div class="ProjectTemplate_customImage__wSvfz"><img alt="Project Methodologies used in the code" loading="lazy" decoding="async" data-nimg="fill" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" sizes="100vw" srcSet="/_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc2.875212b4.jpg&amp;w=640&amp;q=75 640w, /_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc2.875212b4.jpg&amp;w=750&amp;q=75 750w, /_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc2.875212b4.jpg&amp;w=828&amp;q=75 828w, /_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc2.875212b4.jpg&amp;w=1080&amp;q=75 1080w, /_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc2.875212b4.jpg&amp;w=1200&amp;q=75 1200w, /_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc2.875212b4.jpg&amp;w=1920&amp;q=75 1920w, /_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc2.875212b4.jpg&amp;w=2048&amp;q=75 2048w, /_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc2.875212b4.jpg&amp;w=3840&amp;q=75 3840w" src="/_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc2.875212b4.jpg&amp;w=3840&amp;q=75"/></div></div><p class="ProjectTemplate_imageDescription__B6C1V">Weak scaling for the machine with 64 cores</p></div></div><div class="ProjectTemplate_box__pk1Aa"><div style="flex:1"><div class="ProjectTemplate_descriptionContainer__g40_B"><h2>Performance Comparison: CUDA vs. OpenMP </h2><p class="ProjectTemplate_projectDescription__RSofK">For a problem size of 3,200,000 particles, the CUDA implementation completes in 9.7852 seconds, leveraging GPU parallelism and benefiting from high memory bandwidth. In contrast, the OpenMP implementation takes 100 seconds on 64 threads, hindered by CPU limitations in parallelization and memory band- width. This significant performance difference is attributed to CUDA&#x27;s utilization of GPU&#x27;s massive parallelism and superior memory bandwidth compared to OpenMP’s reliance on CPU cores. The choice between CUDA and OpenMP depends on factors such as hardware availability and application requirements.</p></div></div><div class="ProjectTemplate_imageSection__fIgKC"><div class="ProjectTemplate_imageContainer__Xmpvw"><div class="ProjectTemplate_customImage__wSvfz"><img alt="Project Performance Comparison: CUDA vs. OpenMP " loading="lazy" decoding="async" data-nimg="fill" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" sizes="100vw" srcSet="/_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc3.6597d8bb.png&amp;w=640&amp;q=75 640w, /_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc3.6597d8bb.png&amp;w=750&amp;q=75 750w, /_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc3.6597d8bb.png&amp;w=828&amp;q=75 828w, /_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc3.6597d8bb.png&amp;w=1080&amp;q=75 1080w, /_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc3.6597d8bb.png&amp;w=1200&amp;q=75 1200w, /_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc3.6597d8bb.png&amp;w=1920&amp;q=75 1920w, /_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc3.6597d8bb.png&amp;w=2048&amp;q=75 2048w, /_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc3.6597d8bb.png&amp;w=3840&amp;q=75 3840w" src="/_next/image/?url=%2Frajeshwari179.github.io%2F%2F_next%2Fstatic%2Fmedia%2Fhpc3.6597d8bb.png&amp;w=3840&amp;q=75"/></div></div><p class="ProjectTemplate_imageDescription__B6C1V">Log-log plot of time taken vs number of particles</p></div></div></div><script src="/rajeshwari179.github.io/_next/static/chunks/webpack-6238dfa248d38f1e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/rajeshwari179.github.io/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/rajeshwari179.github.io/_next/static/css/e0b7e5d5ffdc86c6.css\",\"style\"]\n3:HL[\"/rajeshwari179.github.io/_next/static/css/3cc226f0877344cc.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"4:I[5751,[],\"\"]\n6:I[8173,[\"173\",\"static/chunks/173-45ae19e0432c0727.js\",\"729\",\"static/chunks/app/project/4/page-51c71a4d71300c50.js\"],\"Image\"]\n7:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[3462,[\"231\",\"static/chunks/231-af777def82264613.js\",\"185\",\"static/chunks/app/layout-7513d9a03965dc6e.js\"],\"default\"]\nb:I[6130,[],\"\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/rajeshwari179.github.io/_next/static/css/e0b7e5d5ffdc86c6.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L4\",null,{\"buildId\":\"rw08EXohAM_7HdnG9emRL\",\"assetPrefix\":\"/rajeshwari179.github.io\",\"initialCanonicalUrl\":\"/project/4/\",\"initialTree\":[\"\",{\"children\":[\"project\",{\"children\":[\"4\",{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"project\",{\"children\":[\"4\",{\"children\":[\"__PAGE__\",{},[[\"$L5\",[\"$\",\"div\",null,{\"style\":{\"border\":\"2px solid #000\",\"padding\":\"20px\",\"borderRadius\":\"10px\"},\"children\":[[\"$\",\"h1\",null,{\"children\":\"Toy Particle Simulation through Shared Memory Programming\"}],[[\"$\",\"div\",null,{\"className\":\"ProjectTemplate_box__pk1Aa\",\"children\":[[\"$\",\"div\",null,{\"style\":{\"flex\":1},\"children\":[\"$\",\"div\",null,{\"className\":\"ProjectTemplate_descriptionContainer__g40_B\",\"children\":[[\"$\",\"h2\",null,{\"children\":\"Introduction\"}],[\"$\",\"p\",null,{\"className\":\"ProjectTemplate_projectDescription__RSofK\",\"children\":[\"This project focuses on parallelizing a toy particle simulation, a simplified model commonly used in mechanics, biology, and astronomy. In this simulation, particles interact by repelling each other when they come within a specified cutoff distance. This model helps in understanding the dynamics of particle systems and their interactions over time.\",[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"To enhance the performance of the particle simulation, parallel computing techniques using OpenMP and CUDA are employed.\"}],[\"$\",\"li\",null,{\"children\":\" OpenMP allows for efficient distribution of the workload across multiple CPU threads, while CUDA enables offloading computations to the GPU, leveraging its massively parallel architecture. These technologies significantly speed up the simulation, enabling the handling of larger particle systems with greater detail\"}]]}]]}]]}]}],[\"$\",\"div\",null,{\"className\":\"ProjectTemplate_imageSection__fIgKC\",\"children\":[[\"$\",\"div\",null,{\"className\":\"ProjectTemplate_imageContainer__Xmpvw\",\"children\":[\"$\",\"div\",null,{\"className\":\"ProjectTemplate_customImage__wSvfz\",\"children\":[\"$\",\"$L6\",null,{\"src\":{\"src\":\"/rajeshwari179.github.io//_next/static/media/hpc4.934b01cd.png\",\"height\":548,\"width\":548,\"blurDataURL\":\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAAAAADhZOFXAAAANElEQVR42h3IsRHAQAjEwOu/WuwHTmT2s5FGatqX6KyaQZ0R756KJxnkOnnA8pjrD5Yarw+n4z2eKq9xAwAAAABJRU5ErkJggg==\",\"blurWidth\":8,\"blurHeight\":8},\"alt\":\"Project Introduction\",\"layout\":\"fill\"}]}]}],[\"$\",\"p\",null,{\"className\":\"ProjectTemplate_imageDescription__B6C1V\",\"children\":\"Grid based Interaction\"}]]}]]}],[\"$\",\"div\",null,{\"className\":\"ProjectTemplate_box__pk1Aa\",\"children\":[[\"$\",\"div\",null,{\"style\":{\"flex\":1},\"children\":[\"$\",\"div\",null,{\"className\":\"ProjectTemplate_descriptionContainer__g40_B\",\"children\":[[\"$\",\"h2\",null,{\"children\":\"Grid-Based Method for Optimization\"}],[\"$\",\"p\",null,{\"className\":\"ProjectTemplate_projectDescription__RSofK\",\"children\":[\"Optimization of force calculations between particles is achieved through a grid-based method. In this approach, the 2D simulation space is divided into grid cells, with each cell's dimensions equal to the cutoff radius of the particles. This spatial partitioning confines the interaction calculations to particles within the same cell or adjacent cells, thus reducing the number of necessary calculations.\",[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"Efficient Force Calculation: The grid-based method reduces computational complexity by focusing only on interactions between nearby particles.\"}],[\"$\",\"li\",null,{\"children\":\"Partitioning the Space: The 2D space is divided into grid cells, each matching the particle interaction cutoff distance\"}],[\"$\",\"li\",null,{\"children\":\"Managing Particles with Sets: Particle indices within each grid cell are managed using sets, ensuring uniqueness within each cell\"}],[\"$\",\"li\",null,{\"children\":\"Localized Force Computation: Forces are calculated only between particles in the same cell or neighboring cells, minimizing the number of interactions considered.\"}]]}],\"Combining the grid-based method with parallel computing techniques results in a highly efficient simulation, capable of handling large-scale particle systems with improved performance. This project demonstrates the effective use of spatial partitioning and parallelization to optimize computationally intensive simulations.\"]}]]}]}],[\"$\",\"div\",null,{\"className\":\"ProjectTemplate_imageSection__fIgKC\",\"children\":[[\"$\",\"div\",null,{\"className\":\"ProjectTemplate_imageContainer__Xmpvw\",\"children\":[\"$\",\"div\",null,{\"className\":\"ProjectTemplate_customImage__wSvfz\",\"children\":[\"$\",\"$L6\",null,{\"src\":{\"src\":\"/rajeshwari179.github.io//_next/static/media/hpc1.84710b57.png\",\"height\":736,\"width\":1190,\"blurDataURL\":\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAMAAABPT11nAAAATlBMVEX8/Pz+/v7+/v39/fz8/P38/Pz7/P36+vr29vb8/Pz+/v7+/v3+/f39/f79/f38/f38/P38/Pz7/P37+/37+/z6+/36+v35+vz19fXy8/Wvb4kdAAAACnRSTlP2+vr6+vr6+vr74LaQQgAAADFJREFUeNoFQIcRgCAQiwUVlfChs/+iHN7wjZnTCdKqWbmg1Ej+O9ilKHlsh7sf57EANMUCEJ+BUHMAAAAASUVORK5CYII=\",\"blurWidth\":8,\"blurHeight\":5},\"alt\":\"Project Grid-Based Method for Optimization\",\"layout\":\"fill\"}]}]}],[\"$\",\"p\",null,{\"className\":\"ProjectTemplate_imageDescription__B6C1V\",\"children\":\" Strong scalling for 50000 paricles  \"}]]}]]}],[\"$\",\"div\",null,{\"className\":\"ProjectTemplate_box__pk1Aa\",\"children\":[[\"$\",\"div\",null,{\"style\":{\"flex\":1},\"children\":[\"$\",\"div\",null,{\"className\":\"ProjectTemplate_descriptionContainer__g40_B\",\"children\":[[\"$\",\"h2\",null,{\"children\":\"Methodologies used in the code\"}],[\"$\",\"p\",null,{\"className\":\"ProjectTemplate_projectDescription__RSofK\",\"children\":[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"Counting Particles per Bin (fill count kernel): Iterates over all particles to determine the number of particles in each bin. Uses atomic operations to increment bin counts to avoid race conditions.\"}],[\"$\",\"li\",null,{\"children\":\"Calculating Cumulative Offset (calc cumulative offset step function): Performs an inclusive scan operation on the bin count array to compute cumulative sums, generating offsets that indicate particle positions in the particles array.\"}],[\"$\",\"li\",null,{\"children\":\"Binning Particles (binning kernel): Assigns each particle to its appropriate bin based on computed offsets. Uses atomic operations to ensure correct placement within the particles array.\"}],[\"$\",\"li\",null,{\"children\":\"Efficient Binning with Offset Array: Utilizes an offset array to store cumulative offsets, optimizing particle assignment to bins without the need for sorting. This approach reduces memory overhead and maximizes GPU parallelism for efficient particle simulation.\"}]]}]}]]}]}],[\"$\",\"div\",null,{\"className\":\"ProjectTemplate_imageSection__fIgKC\",\"children\":[[\"$\",\"div\",null,{\"className\":\"ProjectTemplate_imageContainer__Xmpvw\",\"children\":[\"$\",\"div\",null,{\"className\":\"ProjectTemplate_customImage__wSvfz\",\"children\":[\"$\",\"$L6\",null,{\"src\":{\"src\":\"/rajeshwari179.github.io//_next/static/media/hpc2.875212b4.jpg\",\"height\":448,\"width\":748,\"blurDataURL\":\"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoKCgoKCgsMDAsPEA4QDxYUExMUFiIYGhgaGCIzICUgICUgMy03LCksNy1RQDg4QFFeT0pPXnFlZXGPiI+7u/sBCgoKCgoKCwwMCw8QDhAPFhQTExQWIhgaGBoYIjMgJSAgJSAzLTcsKSw3LVFAODhAUV5PSk9ecWVlcY+Ij7u7+//CABEIAAUACAMBIgACEQEDEQH/xAAnAAEBAAAAAAAAAAAAAAAAAAAABwEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAAsYP/xAAUEAEAAAAAAAAAAAAAAAAAAAAA/9oACAEBAAE/AH//xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oACAECAQE/AH//xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oACAEDAQE/AH//2Q==\",\"blurWidth\":8,\"blurHeight\":5},\"alt\":\"Project Methodologies used in the code\",\"layout\":\"fill\"}]}]}],[\"$\",\"p\",null,{\"className\":\"ProjectTemplate_imageDescription__B6C1V\",\"children\":\"Weak scaling for the machine with 64 cores\"}]]}]]}],[\"$\",\"div\",null,{\"className\":\"ProjectTemplate_box__pk1Aa\",\"children\":[[\"$\",\"div\",null,{\"style\":{\"flex\":1},\"children\":[\"$\",\"div\",null,{\"className\":\"ProjectTemplate_descriptionContainer__g40_B\",\"children\":[[\"$\",\"h2\",null,{\"children\":\"Performance Comparison: CUDA vs. OpenMP \"}],[\"$\",\"p\",null,{\"className\":\"ProjectTemplate_projectDescription__RSofK\",\"children\":\"For a problem size of 3,200,000 particles, the CUDA implementation completes in 9.7852 seconds, leveraging GPU parallelism and benefiting from high memory bandwidth. In contrast, the OpenMP implementation takes 100 seconds on 64 threads, hindered by CPU limitations in parallelization and memory band- width. This significant performance difference is attributed to CUDA's utilization of GPU's massive parallelism and superior memory bandwidth compared to OpenMP’s reliance on CPU cores. The choice between CUDA and OpenMP depends on factors such as hardware availability and application requirements.\"}]]}]}],[\"$\",\"div\",null,{\"className\":\"ProjectTemplate_imageSection__fIgKC\",\"children\":[[\"$\",\"div\",null,{\"className\":\"ProjectTemplate_imageContainer__Xmpvw\",\"children\":[\"$\",\"div\",null,{\"className\":\"ProjectTemplate_customImage__wSvfz\",\"children\":[\"$\",\"$L6\",null,{\"src\":{\"src\":\"/rajeshwari179.github.io//_next/static/media/hpc3.6597d8bb.png\",\"height\":728,\"width\":1196,\"blurDataURL\":\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAMAAABPT11nAAAARVBMVEX8/Pz+/v79/f38/Pz9/fz8/P3+/v79/f37+/z//v7+/v79/f79/f38/f38/P38/Pz7/P37+/37+/z6+vz6+vr5+fz39/fk2IsLAAAACXRSTlPv9vb29/f4+f6ugzhlAAAAL0lEQVR42gVACRLAEBBLbfWIOBf/f6rB3iKZIiQqe4+YdSz/dKN6K7/4IoTLzB4cLX4Buk3ThrkAAAAASUVORK5CYII=\",\"blurWidth\":8,\"blurHeight\":5},\"alt\":\"Project Performance Comparison: CUDA vs. OpenMP \",\"layout\":\"fill\"}]}]}],[\"$\",\"p\",null,{\"className\":\"ProjectTemplate_imageDescription__B6C1V\",\"children\":\"Log-log plot of time taken vs number of particles\"}]]}]]}]]]}]],null],null]},[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"project\",\"children\",\"4\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/rajeshwari179.github.io/_next/static/css/3cc226f0877344cc.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]]}],null]},[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"project\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_ae7d09\",\"children\":[[\"$\",\"div\",null,{\"id\":\"title\",\"className\":\"title\"}],[\"$\",\"$L9\",null,{}],[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"styles\":null}]]}]}],null],null],\"couldBeIntercepted\":false,\"initialHead\":[false,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Create Next App\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"Generated by create next app\"}],[\"$\",\"link\",\"4\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"5\",{\"name\":\"next-size-adjust\"}]]\n5:null\n"])</script></body></html>